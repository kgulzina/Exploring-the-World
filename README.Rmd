---
title: "Lab 2"
authors: "Miranda Tilton, Gulzina Kuttubekova, Atousa Zarindast, Zhenzhen Chen"
date: "February 20, 2019"
output: html_document
---

Link to the repo:
```{r}
link <- "https://github.com/kgulzina/stat585lab2"
```



Libraries:
```{r, include = FALSE} 
library(ggplot2)
library(maps)
library(sf)
library(dplyr)
library(purrr)
library(ggspatial)
```



Fun with Middle Earth. We added labels for the cities using package: "ggspatial".
```{r}
# read the data set
cities <- read_sf("data/ME-GIS-master/Cities.shp")

# plot middle earth
p <- ggplot() +
  geom_sf(data = read_sf("data/ME-GIS-master/Coastline2.shp"), 
          colour="grey10", fill="grey90") +
  geom_sf(data = read_sf("data/ME-GIS-master/Rivers19.shp"), 
          colour="steelblue", size=0.3) +
  geom_sf(data = read_sf("data/ME-GIS-master/PrimaryRoads.shp"), 
          size = 0.7, colour="grey30") +
  geom_sf(data = read_sf("data/ME-GIS-master/Cities.shp")) +
  geom_sf_text(mapping = aes(label = Name), data = cities) + 
  annotation_scale () + 
  annotation_north_arrow () +
  theme_bw()
```



Australia shapefile:
```{r}
ozbig <- read_sf("data/gadm36_AUS_shp/gadm36_AUS_1.shp")

oz_st <- maptools::thinnedSpatialPoly(
  as(ozbig, "Spatial"), tolerance = 0.1, 
  minarea = 0.001, topologyPreserve = TRUE)
oz <- st_as_sf(oz_st)
```

Some data exploration. Inner works: 
```{r}
# check if list
is.list(oz$geometry)

# check is double list
str(oz$geometry[[1]])

# see the matrix (any random)
head(oz$geometry[[11]][[1]][[1]])
```



Write a helper function to turn one of these matrices into a single data frame with variables long, lat, group, order. Use purrr functionality to create a dataframe ozplus from the geometry variable. Plot the result with the command:

Atousa:
```{r}
# try to read one matrix
m1 <- map_depth(.x=oz$geometry, .depth=3,  .f=data.frame)


m2<-(m1)
m22<-flatten_dfr(m1)
m3 <- map_dfc(m2, flatten(m1),.id = row())

m4<-m2%>%tidyr::unnest()
map_dbl(.x=oz$geometry,.f=mutate())
m2<-map(oz$geometry, .f=mutate(lenght()))

group_fun <- function (i) { mutate(group=paste(i))}
  

 t<-m1[[11]][[1]][[1]] %>% mutate(variable=paste("2"))
 

map_dfr(.f=mutate(group=length()) m1)

for (i in c(1:11)){
  for (j in c(1:length(m1[[i]]))){ 
    for (k in c(1:sum(length(m1[[i]][[j]])))){
    print(paste("i",i,"j_",j))
    print(paste("j",j))
    #(print(m1[[i]][[j]][[1]]))
    m1[[i]][[j]][[k]]<-m1[[i]][[j]][[k]]%>%mutate(group=paste(i+j))
 
  options(error=recover) 
      
    }
  }
}
``` 






Gulzina: (Miranda can you please take a look at this?)
Read the data containing the coordinates into one dataframe and plot the resulting dataframe as a polygon:
```{r}
# write a function (something goes wrong here)
extract_data <- function(spf) {
# Reads in the shapefile and extracts data from nested lists, finally
# recording them into one data frame with columns: long, lat, group and
# order.
#
# Args:
#   spf:    shapefile of a country
#
# Output:
#   df:     data frame
    
    # all matrices will be concatenated to this df
    df <- data.frame(t(1:3))
    colnames(df) <- c("long", "lat", "group")
    
    # start group enumeration
    count = 1
    
    # use loops to read nested lists
    for (f in 1:length(spf$geometry)) {
        for (i in 1:length(spf$geometry[[f]])) {
            temp <- map_depth(spf$geometry[[f]][[i]], 1, .f = c(1))
            temp <- data.frame(matrix(unlist(temp), ncol = 2, byrow
                                      = FALSE))
            colnames(temp) <- c("long", "lat")
            temp$group <- rep(count, times = nrow(temp))
            df <- rbind(df, temp)
            count <- count + 1
        }
    }
    
    # remove first row
    df <- df[-1,]
    
    # add order variable
    df$order <- as.integer(seq(from = 1, to = nrow(df), 
                                   by = 1))
    return(df)
}


extract_data_alt <- function(spf) {
# Reads in the shapefile and extracts data from nested lists, finally
# recording them into one data frame with columns: long, lat, group and
# order.
#
# Args:
#   spf:    shapefile of a country
#
# Output:
#   df:     data frame
    
    # pull each first element from nested lists
    # remove hierarchy by flatten
    # map list with 6705 lists to data.frame function
    # add new variable = "group"
    map_depth(.x = spf$geometry, 2, .f = c(1)) %>% flatten %>% 
        map_dfr(data.frame, .id = "group") -> df 
    
    # rename columns
    colnames(df) <- c("group", "long", "lat")
    
    # add new variable = "order"
    df$order <- seq(from = 1, to = nrow(df), by = 1)
    
    return(df)
}


ozplus_alt <- extract_data_alt(oz)

# plot
ozplus_alt %>% ggplot(aes(x = long, y = lat, group = group, na.rm = TRUE)) + geom_polygon(colour = "black", fill = "grey50")


#######################################################################
# tried to use the first function
ozplus <- extract_data(oz)

# plot
ozplus %>% ggplot(aes(x = long, y = lat, group = group, na.rm = TRUE)) + geom_polygon(colour = "black", fill = "grey50")
## something is wrong here: some coordinates are out of boundaries?

## Possible Remedy
# trying to remove some coordinates
new_ozplus <- ozplus[-which(0 < ozplus$lat),-4]
new_ozplus <- new_ozplus[-which(new_ozplus$long < 0),]
new_ozplus$order <- seq(1, nrow(new_ozplus), 1)

# plot the polygon
new_ozplus %>% ggplot(aes(x = long, y = lat, group = group, na.rm = TRUE)) + geom_polygon(colour = "black", fill = "grey50")
## but now we lost some tiny parts of Australia :D
```




GADM: is a service to provide boundaries without borders.

I choose Kyrgyzstan(for trial, we can change it for any other), and downloaded the shapefile. Read the shapefile and thin it, extract the data and plot the polygon:
```{r}
# read data
kgbig <- read_sf("data/gadm36_KGZ_shp/gadm36_KGZ_1.shp")

kg_st <- maptools::thinnedSpatialPoly(
  as(kgbig, "Spatial"), tolerance = 0.1, 
  minarea = 0.001, topologyPreserve = TRUE)
kg <- st_as_sf(kg_st)

# trying the original function on this data, and it works
kgplus <- extract_data(kg)

kgplus %>% ggplot(aes(x = long, y = lat, group = group, na.rm = TRUE)) + geom_polygon(colour = "black", fill = "grey50")
```
Pretty good plot. Resembles my country :D




Mapping Turkey by using alternative function:
```{r}
turbig <- read_sf("data/gadm36_TUR_shp/gadm36_TUR_1.shp")

tur_st <- maptools::thinnedSpatialPoly(
  as(turbig, "Spatial"), tolerance = 0.1, 
  minarea = 0.001, topologyPreserve = TRUE)
tur <- st_as_sf(tur_st)

# trying the same function on this data
turplus <- extract_data_alt(tur)

turplus %>% ggplot(aes(x = long, y = lat, group = group, na.rm = TRUE)) + geom_polygon(colour = "black", fill = "grey50")
```



























